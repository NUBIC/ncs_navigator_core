# -*- coding: utf-8 -*-
Given /^the sync attempts$/ do |table|
  table.hashes.each do |sync|
    id = sync['id']
    status = sync['status']

    step %Q{a fieldwork packet for "#{id}"}

    # Munge status.
    fw = Fieldwork.find_by_fieldwork_id(id)

    fw.update_attribute(:latest_merge_status, status)
  end
end

Given /^a fieldwork packet for "([^"]*)"$/ do |id|
  steps %Q{
    Given the payload
    """
    {}
    """
    When I PUT the payload to /api/v1/fieldwork/#{id}.json with
      | header:X-Client-ID | foo |
    Then the response status is 204
  }
end

Given /^merging "([^"]*)" caused conflicts$/ do |fw_id, table|
  fw = Fieldwork.find_by_fieldwork_id(fw_id)

  report = ConflictReport.new

  table.hashes.each do |h|
    entity, public_id = h['entity'].split(' ')

    report.add(entity, public_id, h['attribute'], h['original'], h['current'], h['proposed'])
  end

  fw.merges.create!(:conflict_report => report, :staff_id => 'foo', :client_id => 'bar', :username => 'baz')
end

# NB: These Then-steps rely on Capybara's #all returning elements in a
# predictable order across invocations.  So far, this seems to be true.

Then /^I see the sync attempts$/ do |table|
  ids = all('.sync_attempt .fieldwork_id').map(&:text).map(&:strip)
  originators = all('.sync_attempt .originator').map(&:text).map(&:strip)
  statuses = all('.sync_attempt .status').map(&:text).map(&:strip)

  actual = [['id', 'generated by', 'status']] + ids.zip(originators, statuses)

  table.diff!(actual)
end

Then /^I see the conflict report$/ do |table|
  keys = %w(entity attribute original current proposed)

  values = keys.map do |klass|
    all(".conflict_report .#{klass}").map(&:text).map(&:strip)
  end

  actual = [keys] + values.first.zip(*values[1..-1])

  table.diff!(actual)
end

Given /^the participant person link$/ do |table|
  table.map_column!('relationship_code') { |c| c.to_i }
  table.hashes.each do |hash|
    p_id = hash.delete('p_id')
    person_id = hash.delete('person_id')
    hash.merge!(
      :participant => Participant.where(:p_id => p_id).first, 
      :person => Person.where(:person_id => person_id).first)

    Factory(:participant_person_link, hash)
  end
end

Then /^the response body has "([^"]*)" distinct values for "([^"]*)" at "([^"]*)"$/ do |count, element, root|
  json = JSON.parse(last_response.body)
  ptr = Hana::Pointer.new(root)
  val = ptr.eval(json)
  val.map{|v| v[element] }.uniq.size.should == count.to_i
end