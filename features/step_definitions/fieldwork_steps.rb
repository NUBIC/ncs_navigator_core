# -*- coding: utf-8 -*-
Given /^the sync attempts$/ do |table|
  table.hashes.each do |sync|
    id = sync['id']
    status = sync['status']

    step %Q{a fieldwork packet for "#{id}"}

    # Munge status.
    fw = Fieldwork.find_by_fieldwork_id(id)

    fw.update_attribute(:latest_merge_status, status)
  end
end

Given /^a fieldwork packet for "([^"]*)"$/ do |id|
  steps %Q{
    Given the payload
    """
    {}
    """
    When I PUT the payload to /api/v1/fieldwork/#{id}.json with
      | header:X-Client-ID | foo |
    Then the response status is 204
  }
end

Given /^merging "([^"]*)" caused conflicts$/ do |fw_id, table|
  fw = Fieldwork.find_by_fieldwork_id(fw_id)

  report = ConflictReport.new

  table.hashes.each do |h|
    entity, public_id = h['entity'].split(' ')

    report.add(entity, public_id, h['attribute'], h['original'], h['current'], h['proposed'])
  end

  fw.merges.create!(:conflict_report => report, :staff_id => 'foo', :client_id => 'bar', :username => 'baz')
end

# NB: These Then-steps rely on Capybara's #all returning elements in a
# predictable order across invocations.  So far, this seems to be true.

Then /^I see the sync attempts$/ do |table|
  ids = all('.sync_attempt .fieldwork_id').map(&:text).map(&:strip)
  originators = all('.sync_attempt .originator').map(&:text).map(&:strip)
  statuses = all('.sync_attempt .status').map(&:text).map(&:strip)

  actual = [['id', 'generated by', 'status']] + ids.zip(originators, statuses)

  table.diff!(actual)
end

Then /^I see the conflict report$/ do |table|
  keys = %w(entity attribute original current proposed)

  values = keys.map do |klass|
    all(".conflict_report .#{klass}").map(&:text).map(&:strip)
  end

  actual = [keys] + values.first.zip(*values[1..-1])

  table.diff!(actual)
end
